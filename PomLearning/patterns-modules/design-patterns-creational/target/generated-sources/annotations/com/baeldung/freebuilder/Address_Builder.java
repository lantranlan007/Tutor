// Autogenerated code. Do not modify.
package com.baeldung.freebuilder;

import java.util.EnumSet;
import java.util.Objects;
import java.util.Optional;
import java.util.function.UnaryOperator;
import javax.annotation.Nullable;

/**
 * Auto-generated superclass of {@link Address.Builder}, derived from the API of {@link Address}.
 */
abstract class Address_Builder {

  /**
   * Creates a new builder using {@code value} as a template.
   *
   * <p>If {@code value} is a partial, the builder will return more partials.
   */
  public static Address.Builder from(Address value) {
    if (value instanceof Rebuildable) {
      return ((Rebuildable) value).toBuilder();
    } else {
      return new Address.Builder().mergeFrom(value);
    }
  }

  private enum Property {
    CITY("city"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String addressLine1 = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String addressLine2 = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String addressLine3 = null;
  private String city;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String state = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private Long pinCode = null;
  private final EnumSet<Property> _unsetProperties = EnumSet.allOf(Property.class);

  /**
   * Sets the value to be returned by {@link Address#getAddressLine1()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code addressLine1} is null
   */
  public Address.Builder setAddressLine1(String addressLine1) {
    this.addressLine1 = Objects.requireNonNull(addressLine1);
    return (Address.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine1()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setAddressLine1(Optional<? extends String> addressLine1) {
    if (addressLine1.isPresent()) {
      return setAddressLine1(addressLine1.get());
    } else {
      return clearAddressLine1();
    }
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine1()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setNullableAddressLine1(@Nullable String addressLine1) {
    if (addressLine1 != null) {
      return setAddressLine1(addressLine1);
    } else {
      return clearAddressLine1();
    }
  }

  /**
   * If the value to be returned by {@link Address#getAddressLine1()} is present, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Address.Builder mapAddressLine1(UnaryOperator<String> mapper) {
    return setAddressLine1(getAddressLine1().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine1()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder clearAddressLine1() {
    addressLine1 = null;
    return (Address.Builder) this;
  }

  /** Returns the value that will be returned by {@link Address#getAddressLine1()}. */
  public Optional<String> getAddressLine1() {
    return Optional.ofNullable(addressLine1);
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine2()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code addressLine2} is null
   */
  public Address.Builder setAddressLine2(String addressLine2) {
    this.addressLine2 = Objects.requireNonNull(addressLine2);
    return (Address.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine2()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setAddressLine2(Optional<? extends String> addressLine2) {
    if (addressLine2.isPresent()) {
      return setAddressLine2(addressLine2.get());
    } else {
      return clearAddressLine2();
    }
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine2()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setNullableAddressLine2(@Nullable String addressLine2) {
    if (addressLine2 != null) {
      return setAddressLine2(addressLine2);
    } else {
      return clearAddressLine2();
    }
  }

  /**
   * If the value to be returned by {@link Address#getAddressLine2()} is present, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Address.Builder mapAddressLine2(UnaryOperator<String> mapper) {
    return setAddressLine2(getAddressLine2().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine2()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder clearAddressLine2() {
    addressLine2 = null;
    return (Address.Builder) this;
  }

  /** Returns the value that will be returned by {@link Address#getAddressLine2()}. */
  public Optional<String> getAddressLine2() {
    return Optional.ofNullable(addressLine2);
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine3()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code addressLine3} is null
   */
  public Address.Builder setAddressLine3(String addressLine3) {
    this.addressLine3 = Objects.requireNonNull(addressLine3);
    return (Address.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine3()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setAddressLine3(Optional<? extends String> addressLine3) {
    if (addressLine3.isPresent()) {
      return setAddressLine3(addressLine3.get());
    } else {
      return clearAddressLine3();
    }
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine3()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setNullableAddressLine3(@Nullable String addressLine3) {
    if (addressLine3 != null) {
      return setAddressLine3(addressLine3);
    } else {
      return clearAddressLine3();
    }
  }

  /**
   * If the value to be returned by {@link Address#getAddressLine3()} is present, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Address.Builder mapAddressLine3(UnaryOperator<String> mapper) {
    return setAddressLine3(getAddressLine3().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Address#getAddressLine3()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder clearAddressLine3() {
    addressLine3 = null;
    return (Address.Builder) this;
  }

  /** Returns the value that will be returned by {@link Address#getAddressLine3()}. */
  public Optional<String> getAddressLine3() {
    return Optional.ofNullable(addressLine3);
  }

  /**
   * Sets the value to be returned by {@link Address#getCity()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code city} is null
   */
  public Address.Builder setCity(String city) {
    this.city = Objects.requireNonNull(city);
    _unsetProperties.remove(Property.CITY);
    return (Address.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Address#getCity()} by applying {@code mapper} to it
   * and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Address.Builder mapCity(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setCity(mapper.apply(getCity()));
  }

  /**
   * Returns the value that will be returned by {@link Address#getCity()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getCity() {
    if (_unsetProperties.contains(Property.CITY)) {
      throw new IllegalStateException("city not set");
    }
    return city;
  }

  /**
   * Sets the value to be returned by {@link Address#getState()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code state} is null
   */
  public Address.Builder setState(String state) {
    this.state = Objects.requireNonNull(state);
    return (Address.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Address#getState()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setState(Optional<? extends String> state) {
    if (state.isPresent()) {
      return setState(state.get());
    } else {
      return clearState();
    }
  }

  /**
   * Sets the value to be returned by {@link Address#getState()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setNullableState(@Nullable String state) {
    if (state != null) {
      return setState(state);
    } else {
      return clearState();
    }
  }

  /**
   * If the value to be returned by {@link Address#getState()} is present, replaces it by applying
   * {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Address.Builder mapState(UnaryOperator<String> mapper) {
    return setState(getState().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Address#getState()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder clearState() {
    state = null;
    return (Address.Builder) this;
  }

  /** Returns the value that will be returned by {@link Address#getState()}. */
  public Optional<String> getState() {
    return Optional.ofNullable(state);
  }

  /**
   * Sets the value to be returned by {@link Address#getPinCode()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setPinCode(long pinCode) {
    this.pinCode = pinCode;
    return (Address.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Address#getPinCode()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setPinCode(Optional<? extends Long> pinCode) {
    if (pinCode.isPresent()) {
      return setPinCode(pinCode.get());
    } else {
      return clearPinCode();
    }
  }

  /**
   * Sets the value to be returned by {@link Address#getPinCode()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder setNullablePinCode(@Nullable Long pinCode) {
    if (pinCode != null) {
      return setPinCode(pinCode);
    } else {
      return clearPinCode();
    }
  }

  /**
   * If the value to be returned by {@link Address#getPinCode()} is present, replaces it by applying
   * {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Address.Builder mapPinCode(UnaryOperator<Long> mapper) {
    return setPinCode(getPinCode().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Address#getPinCode()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder clearPinCode() {
    pinCode = null;
    return (Address.Builder) this;
  }

  /** Returns the value that will be returned by {@link Address#getPinCode()}. */
  public Optional<Long> getPinCode() {
    return Optional.ofNullable(pinCode);
  }

  /**
   * Copies values from {@code value}, skipping empty optionals.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder mergeFrom(Address value) {
    value.getAddressLine1().ifPresent(this::setAddressLine1);
    value.getAddressLine2().ifPresent(this::setAddressLine2);
    value.getAddressLine3().ifPresent(this::setAddressLine3);
    Address_Builder defaults = new Address.Builder();
    if (defaults._unsetProperties.contains(Property.CITY)
        || !Objects.equals(value.getCity(), defaults.getCity())) {
      setCity(value.getCity());
    }
    value.getState().ifPresent(this::setState);
    value.getPinCode().ifPresent(this::setPinCode);
    return (Address.Builder) this;
  }

  /**
   * Copies values from {@code template}, skipping empty optionals and unset properties.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder mergeFrom(Address.Builder template) {
    template.getAddressLine1().ifPresent(this::setAddressLine1);
    template.getAddressLine2().ifPresent(this::setAddressLine2);
    template.getAddressLine3().ifPresent(this::setAddressLine3);
    // Upcast to access private fields; otherwise, oddly, we get an access violation.
    Address_Builder base = template;
    Address_Builder defaults = new Address.Builder();
    if (!base._unsetProperties.contains(Property.CITY)
        && (defaults._unsetProperties.contains(Property.CITY)
            || !Objects.equals(template.getCity(), defaults.getCity()))) {
      setCity(template.getCity());
    }
    template.getState().ifPresent(this::setState);
    template.getPinCode().ifPresent(this::setPinCode);
    return (Address.Builder) this;
  }

  /**
   * Resets the state of this builder.
   *
   * @return this {@code Builder} object
   */
  public Address.Builder clear() {
    Address_Builder defaults = new Address.Builder();
    addressLine1 = defaults.addressLine1;
    addressLine2 = defaults.addressLine2;
    addressLine3 = defaults.addressLine3;
    city = defaults.city;
    state = defaults.state;
    pinCode = defaults.pinCode;
    _unsetProperties.clear();
    _unsetProperties.addAll(defaults._unsetProperties);
    return (Address.Builder) this;
  }

  /**
   * Returns a newly-created {@link Address} based on the contents of this {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public Address build() {
    if (!_unsetProperties.isEmpty()) {
      throw new IllegalStateException("Not set: " + _unsetProperties);
    }
    return new Value(this);
  }

  /**
   * Returns a newly-created partial {@link Address} for use in unit tests. State checking will not
   * be performed. Unset properties will throw an {@link UnsupportedOperationException} when
   * accessed via the partial object.
   *
   * <p>The builder returned by {@link Address.Builder#from(Address)} will propagate the partial
   * status of its input, overriding {@link Address.Builder#build() build()} to return another
   * partial. This allows for robust tests of modify-rebuild code.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  public Address buildPartial() {
    return new Partial(this);
  }

  private abstract static class Rebuildable implements Address {
    public abstract Builder toBuilder();
  }

  private static final class Value extends Rebuildable {
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String addressLine1;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String addressLine2;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String addressLine3;
    private final String city;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String state;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final Long pinCode;

    private Value(Address_Builder builder) {
      this.addressLine1 = builder.addressLine1;
      this.addressLine2 = builder.addressLine2;
      this.addressLine3 = builder.addressLine3;
      this.city = builder.city;
      this.state = builder.state;
      this.pinCode = builder.pinCode;
    }

    @Override
    public Optional<String> getAddressLine1() {
      return Optional.ofNullable(addressLine1);
    }

    @Override
    public Optional<String> getAddressLine2() {
      return Optional.ofNullable(addressLine2);
    }

    @Override
    public Optional<String> getAddressLine3() {
      return Optional.ofNullable(addressLine3);
    }

    @Override
    public String getCity() {
      return city;
    }

    @Override
    public Optional<String> getState() {
      return Optional.ofNullable(state);
    }

    @Override
    public Optional<Long> getPinCode() {
      return Optional.ofNullable(pinCode);
    }

    @Override
    public Builder toBuilder() {
      Address_Builder builder = new Builder();
      builder.addressLine1 = addressLine1;
      builder.addressLine2 = addressLine2;
      builder.addressLine3 = addressLine3;
      builder.city = city;
      builder.state = state;
      builder.pinCode = pinCode;
      builder._unsetProperties.clear();
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Value)) {
        return false;
      }
      Value other = (Value) obj;
      return Objects.equals(addressLine1, other.addressLine1)
          && Objects.equals(addressLine2, other.addressLine2)
          && Objects.equals(addressLine3, other.addressLine3)
          && Objects.equals(city, other.city)
          && Objects.equals(state, other.state)
          && Objects.equals(pinCode, other.pinCode);
    }

    @Override
    public int hashCode() {
      return Objects.hash(addressLine1, addressLine2, addressLine3, city, state, pinCode);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("Address{");
      if (addressLine1 != null) {
        result.append("addressLine1=").append(addressLine1).append(", ");
      }
      if (addressLine2 != null) {
        result.append("addressLine2=").append(addressLine2).append(", ");
      }
      if (addressLine3 != null) {
        result.append("addressLine3=").append(addressLine3).append(", ");
      }
      result.append("city=").append(city);
      if (state != null) {
        result.append(", state=").append(state);
      }
      if (pinCode != null) {
        result.append(", pinCode=").append(pinCode);
      }
      return result.append("}").toString();
    }
  }

  private static final class Partial extends Rebuildable {
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String addressLine1;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String addressLine2;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String addressLine3;
    private final String city;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String state;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final Long pinCode;
    private final EnumSet<Property> _unsetProperties;

    Partial(Address_Builder builder) {
      this.addressLine1 = builder.addressLine1;
      this.addressLine2 = builder.addressLine2;
      this.addressLine3 = builder.addressLine3;
      this.city = builder.city;
      this.state = builder.state;
      this.pinCode = builder.pinCode;
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    public Optional<String> getAddressLine1() {
      return Optional.ofNullable(addressLine1);
    }

    @Override
    public Optional<String> getAddressLine2() {
      return Optional.ofNullable(addressLine2);
    }

    @Override
    public Optional<String> getAddressLine3() {
      return Optional.ofNullable(addressLine3);
    }

    @Override
    public String getCity() {
      if (_unsetProperties.contains(Property.CITY)) {
        throw new UnsupportedOperationException("city not set");
      }
      return city;
    }

    @Override
    public Optional<String> getState() {
      return Optional.ofNullable(state);
    }

    @Override
    public Optional<Long> getPinCode() {
      return Optional.ofNullable(pinCode);
    }

    private static class PartialBuilder extends Builder {
      @Override
      public Address build() {
        return buildPartial();
      }
    }

    @Override
    public Builder toBuilder() {
      Address_Builder builder = new PartialBuilder();
      builder.addressLine1 = addressLine1;
      builder.addressLine2 = addressLine2;
      builder.addressLine3 = addressLine3;
      builder.city = city;
      builder.state = state;
      builder.pinCode = pinCode;
      builder._unsetProperties.clear();
      builder._unsetProperties.addAll(_unsetProperties);
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Partial)) {
        return false;
      }
      Partial other = (Partial) obj;
      return Objects.equals(addressLine1, other.addressLine1)
          && Objects.equals(addressLine2, other.addressLine2)
          && Objects.equals(addressLine3, other.addressLine3)
          && Objects.equals(city, other.city)
          && Objects.equals(state, other.state)
          && Objects.equals(pinCode, other.pinCode)
          && Objects.equals(_unsetProperties, other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Objects.hash(
          addressLine1, addressLine2, addressLine3, city, state, pinCode, _unsetProperties);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("partial Address{");
      String separator = "";
      if (addressLine1 != null) {
        result.append("addressLine1=").append(addressLine1);
        separator = ", ";
      }
      if (addressLine2 != null) {
        result.append(separator).append("addressLine2=").append(addressLine2);
        separator = ", ";
      }
      if (addressLine3 != null) {
        result.append(separator).append("addressLine3=").append(addressLine3);
        separator = ", ";
      }
      if (!_unsetProperties.contains(Property.CITY)) {
        result.append(separator).append("city=").append(city);
        separator = ", ";
      }
      if (state != null) {
        result.append(separator).append("state=").append(state);
        separator = ", ";
      }
      if (pinCode != null) {
        result.append(separator).append("pinCode=").append(pinCode);
      }
      return result.append("}").toString();
    }
  }
}

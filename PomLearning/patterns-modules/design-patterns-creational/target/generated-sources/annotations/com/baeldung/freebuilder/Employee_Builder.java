// Autogenerated code. Do not modify.
package com.baeldung.freebuilder;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import java.util.function.UnaryOperator;
import java.util.stream.BaseStream;
import javax.annotation.Nullable;

/**
 * Auto-generated superclass of {@link Employee.Builder}, derived from the API of {@link Employee}.
 */
abstract class Employee_Builder {

  /**
   * Creates a new builder using {@code value} as a template.
   *
   * <p>If {@code value} is a partial, the builder will return more partials.
   */
  public static Employee.Builder from(Employee value) {
    if (value instanceof Rebuildable) {
      return ((Rebuildable) value).toBuilder();
    } else {
      return new Employee.Builder().mergeFrom(value);
    }
  }

  private enum Property {
    NAME("name"),
    AGE("age"),
    DEPARTMENT("department"),
    ROLE("role"),
    SUPERVISOR_NAME("supervisorName"),
    DESIGNATION("designation"),
    EMAIL("email"),
    PHONE_NUMBER("phoneNumber"),
    ;

    private final String name;

    private Property(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return name;
    }
  }

  private String name;
  private int age;
  private String department;
  private String role;
  private String supervisorName;
  private String designation;
  private String email;
  private long phoneNumber;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private Boolean permanent = null;
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private String dateOfJoining = null;
  @Nullable private String currentProject = null;
  private Object address = null;
  private final ArrayList<Long> accessTokens = new ArrayList<>();
  private final LinkedHashMap<String, Long> assetsSerialIdMapping = new LinkedHashMap<>();
  // Store a nullable object instead of an Optional. Escape analysis then
  // allows the JVM to optimize away the Optional objects created by and
  // passed to our API.
  private Double salaryInUSD = null;
  private final EnumSet<Property> _unsetProperties = EnumSet.allOf(Property.class);

  /**
   * Sets the value to be returned by {@link Employee#getName()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code name} is null
   */
  public Employee.Builder setName(String name) {
    this.name = Objects.requireNonNull(name);
    _unsetProperties.remove(Property.NAME);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#getName()} by applying {@code mapper} to
   * it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapName(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setName(mapper.apply(getName()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#getName()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getName() {
    if (_unsetProperties.contains(Property.NAME)) {
      throw new IllegalStateException("name not set");
    }
    return name;
  }

  /**
   * Sets the value to be returned by {@link Employee#getAge()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setAge(int age) {
    this.age = age;
    _unsetProperties.remove(Property.AGE);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#getAge()} by applying {@code mapper} to it
   * and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapAge(IntUnaryOperator mapper) {
    Objects.requireNonNull(mapper);
    return setAge(mapper.applyAsInt(getAge()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#getAge()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public int getAge() {
    if (_unsetProperties.contains(Property.AGE)) {
      throw new IllegalStateException("age not set");
    }
    return age;
  }

  /**
   * Sets the value to be returned by {@link Employee#getDepartment()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code department} is null
   */
  public Employee.Builder setDepartment(String department) {
    this.department = Objects.requireNonNull(department);
    _unsetProperties.remove(Property.DEPARTMENT);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#getDepartment()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapDepartment(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setDepartment(mapper.apply(getDepartment()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#getDepartment()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getDepartment() {
    if (_unsetProperties.contains(Property.DEPARTMENT)) {
      throw new IllegalStateException("department not set");
    }
    return department;
  }

  /**
   * Sets the value to be returned by {@link Employee#getRole()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code role} is null
   */
  public Employee.Builder setRole(String role) {
    this.role = Objects.requireNonNull(role);
    _unsetProperties.remove(Property.ROLE);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#getRole()} by applying {@code mapper} to
   * it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapRole(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setRole(mapper.apply(getRole()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#getRole()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getRole() {
    if (_unsetProperties.contains(Property.ROLE)) {
      throw new IllegalStateException("role not set");
    }
    return role;
  }

  /**
   * Sets the value to be returned by {@link Employee#getSupervisorName()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code supervisorName} is null
   */
  public Employee.Builder setSupervisorName(String supervisorName) {
    this.supervisorName = Objects.requireNonNull(supervisorName);
    _unsetProperties.remove(Property.SUPERVISOR_NAME);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#getSupervisorName()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapSupervisorName(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setSupervisorName(mapper.apply(getSupervisorName()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#getSupervisorName()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getSupervisorName() {
    if (_unsetProperties.contains(Property.SUPERVISOR_NAME)) {
      throw new IllegalStateException("supervisorName not set");
    }
    return supervisorName;
  }

  /**
   * Sets the value to be returned by {@link Employee#getDesignation()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code designation} is null
   */
  public Employee.Builder setDesignation(String designation) {
    this.designation = Objects.requireNonNull(designation);
    _unsetProperties.remove(Property.DESIGNATION);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#getDesignation()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapDesignation(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setDesignation(mapper.apply(getDesignation()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#getDesignation()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getDesignation() {
    if (_unsetProperties.contains(Property.DESIGNATION)) {
      throw new IllegalStateException("designation not set");
    }
    return designation;
  }

  /**
   * Sets the value to be returned by {@link Employee#getEmail()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code email} is null
   */
  public Employee.Builder setEmail(String email) {
    this.email = Objects.requireNonNull(email);
    _unsetProperties.remove(Property.EMAIL);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#getEmail()} by applying {@code mapper} to
   * it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null or returns null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapEmail(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    return setEmail(mapper.apply(getEmail()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#getEmail()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public String getEmail() {
    if (_unsetProperties.contains(Property.EMAIL)) {
      throw new IllegalStateException("email not set");
    }
    return email;
  }

  /**
   * Sets the value to be returned by {@link Employee#getPhoneNumber()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setPhoneNumber(long phoneNumber) {
    this.phoneNumber = phoneNumber;
    _unsetProperties.remove(Property.PHONE_NUMBER);
    return (Employee.Builder) this;
  }

  /**
   * Replaces the value to be returned by {@link Employee#getPhoneNumber()} by applying {@code
   * mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   * @throws IllegalStateException if the field has not been set
   */
  public Employee.Builder mapPhoneNumber(LongUnaryOperator mapper) {
    Objects.requireNonNull(mapper);
    return setPhoneNumber(mapper.applyAsLong(getPhoneNumber()));
  }

  /**
   * Returns the value that will be returned by {@link Employee#getPhoneNumber()}.
   *
   * @throws IllegalStateException if the field has not been set
   */
  public long getPhoneNumber() {
    if (_unsetProperties.contains(Property.PHONE_NUMBER)) {
      throw new IllegalStateException("phoneNumber not set");
    }
    return phoneNumber;
  }

  /**
   * Sets the value to be returned by {@link Employee#getPermanent()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setPermanent(boolean permanent) {
    this.permanent = permanent;
    return (Employee.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Employee#getPermanent()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setPermanent(Optional<? extends Boolean> permanent) {
    if (permanent.isPresent()) {
      return setPermanent(permanent.get());
    } else {
      return clearPermanent();
    }
  }

  /**
   * Sets the value to be returned by {@link Employee#getPermanent()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setNullablePermanent(@Nullable Boolean permanent) {
    if (permanent != null) {
      return setPermanent(permanent);
    } else {
      return clearPermanent();
    }
  }

  /**
   * If the value to be returned by {@link Employee#getPermanent()} is present, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Employee.Builder mapPermanent(UnaryOperator<Boolean> mapper) {
    return setPermanent(getPermanent().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Employee#getPermanent()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearPermanent() {
    permanent = null;
    return (Employee.Builder) this;
  }

  /** Returns the value that will be returned by {@link Employee#getPermanent()}. */
  public Optional<Boolean> getPermanent() {
    return Optional.ofNullable(permanent);
  }

  /**
   * Sets the value to be returned by {@link Employee#getDateOfJoining()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code dateOfJoining} is null
   */
  public Employee.Builder setDateOfJoining(String dateOfJoining) {
    this.dateOfJoining = Objects.requireNonNull(dateOfJoining);
    return (Employee.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Employee#getDateOfJoining()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setDateOfJoining(Optional<? extends String> dateOfJoining) {
    if (dateOfJoining.isPresent()) {
      return setDateOfJoining(dateOfJoining.get());
    } else {
      return clearDateOfJoining();
    }
  }

  /**
   * Sets the value to be returned by {@link Employee#getDateOfJoining()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setNullableDateOfJoining(@Nullable String dateOfJoining) {
    if (dateOfJoining != null) {
      return setDateOfJoining(dateOfJoining);
    } else {
      return clearDateOfJoining();
    }
  }

  /**
   * If the value to be returned by {@link Employee#getDateOfJoining()} is present, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Employee.Builder mapDateOfJoining(UnaryOperator<String> mapper) {
    return setDateOfJoining(getDateOfJoining().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Employee#getDateOfJoining()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearDateOfJoining() {
    dateOfJoining = null;
    return (Employee.Builder) this;
  }

  /** Returns the value that will be returned by {@link Employee#getDateOfJoining()}. */
  public Optional<String> getDateOfJoining() {
    return Optional.ofNullable(dateOfJoining);
  }

  /**
   * Sets the value to be returned by {@link Employee#getCurrentProject()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setCurrentProject(@Nullable String currentProject) {
    this.currentProject = currentProject;
    return (Employee.Builder) this;
  }

  /**
   * If the value to be returned by {@link Employee#getCurrentProject()} is not null, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Employee.Builder mapCurrentProject(UnaryOperator<String> mapper) {
    Objects.requireNonNull(mapper);
    String currentProject = getCurrentProject();
    if (currentProject != null) {
      setCurrentProject(mapper.apply(currentProject));
    }
    return (Employee.Builder) this;
  }

  /** Returns the value that will be returned by {@link Employee#getCurrentProject()}. */
  @Nullable
  public String getCurrentProject() {
    return currentProject;
  }

  /**
   * Sets the value to be returned by {@link Employee#getAddress()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code address} is null
   */
  public Employee.Builder setAddress(Address address) {
    Objects.requireNonNull(address);
    if (this.address == null || this.address instanceof Address) {
      this.address = address;
    } else {
      Address.Builder builder = (Address.Builder) this.address;
      builder.clear();
      builder.mergeFrom(address);
    }
    return (Employee.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Employee#getAddress()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code builder} is null
   */
  public Employee.Builder setAddress(Address.Builder builder) {
    return setAddress(builder.build());
  }

  /**
   * Applies {@code mutator} to the builder for the value that will be returned by {@link
   * Employee#getAddress()}.
   *
   * <p>This method mutates the builder in-place. {@code mutator} is a void consumer, so any value
   * returned from a lambda will be ignored.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mutator} is null
   */
  public Employee.Builder mutateAddress(Consumer<Address.Builder> mutator) {
    mutator.accept(getAddressBuilder());
    return (Employee.Builder) this;
  }

  /** Returns a builder for the value that will be returned by {@link Employee#getAddress()}. */
  public Address.Builder getAddressBuilder() {
    if (address == null) {
      address = new Address.Builder();
    } else if (address instanceof Address) {
      Address value = (Address) address;
      address = new Address.Builder().mergeFrom(value);
    }
    Address.Builder builder = (Address.Builder) address;
    return builder;
  }

  /**
   * Adds {@code element} to the list to be returned from {@link Employee#getAccessTokens()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder addAccessTokens(long element) {
    accessTokens.add(element);
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from {@link
   * Employee#getAccessTokens()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder addAccessTokens(long... elements) {
    accessTokens.ensureCapacity(accessTokens.size() + elements.length);
    for (long element : elements) {
      addAccessTokens(element);
    }
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from {@link
   * Employee#getAccessTokens()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllAccessTokens(Spliterator<? extends Long> elements) {
    if ((elements.characteristics() & Spliterator.SIZED) != 0) {
      long elementsSize = elements.estimateSize();
      if (elementsSize > 0 && elementsSize <= Integer.MAX_VALUE) {
        accessTokens.ensureCapacity(accessTokens.size() + (int) elementsSize);
      }
    }
    elements.forEachRemaining(this::addAccessTokens);
    return (Employee.Builder) this;
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from {@link
   * Employee#getAccessTokens()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllAccessTokens(BaseStream<? extends Long, ?> elements) {
    return addAllAccessTokens(elements.spliterator());
  }

  /**
   * Adds each element of {@code elements} to the list to be returned from {@link
   * Employee#getAccessTokens()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code elements} is null or contains a null element
   */
  public Employee.Builder addAllAccessTokens(Iterable<? extends Long> elements) {
    return addAllAccessTokens(elements.spliterator());
  }

  /**
   * Applies {@code mutator} to the list to be returned from {@link Employee#getAccessTokens()}.
   *
   * <p>This method mutates the list in-place. {@code mutator} is a void consumer, so any value
   * returned from a lambda will be ignored. Take care not to call pure functions, like {@link
   * Collection#stream()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mutator} is null
   */
  public Employee.Builder mutateAccessTokens(Consumer<? super List<Long>> mutator) {
    // If addAccessTokens is overridden, this method will be updated to delegate to it
    mutator.accept(accessTokens);
    return (Employee.Builder) this;
  }

  /**
   * Clears the list to be returned from {@link Employee#getAccessTokens()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearAccessTokens() {
    accessTokens.clear();
    return (Employee.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the list that will be returned by {@link
   * Employee#getAccessTokens()}. Changes to this builder will be reflected in the view.
   */
  public List<Long> getAccessTokens() {
    return Collections.unmodifiableList(accessTokens);
  }

  /**
   * Associates {@code key} with {@code value} in the map to be returned from {@link
   * Employee#getAssetsSerialIdMapping()}. If the map previously contained a mapping for the key,
   * the old value is replaced by the specified value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code key} is null
   */
  public Employee.Builder putAssetsSerialIdMapping(String key, long value) {
    Objects.requireNonNull(key);
    assetsSerialIdMapping.put(key, value);
    return (Employee.Builder) this;
  }

  /**
   * Copies all of the mappings from {@code map} to the map to be returned from {@link
   * Employee#getAssetsSerialIdMapping()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code map} is null or contains a null key or value
   */
  public Employee.Builder putAllAssetsSerialIdMapping(Map<? extends String, ? extends Long> map) {
    for (Map.Entry<? extends String, ? extends Long> entry : map.entrySet()) {
      putAssetsSerialIdMapping(entry.getKey(), entry.getValue());
    }
    return (Employee.Builder) this;
  }

  /**
   * Removes the mapping for {@code key} from the map to be returned from {@link
   * Employee#getAssetsSerialIdMapping()}, if one is present.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code key} is null
   */
  public Employee.Builder removeAssetsSerialIdMapping(String key) {
    Objects.requireNonNull(key);
    assetsSerialIdMapping.remove(key);
    return (Employee.Builder) this;
  }

  /**
   * Invokes {@code mutator} with the map to be returned from {@link
   * Employee#getAssetsSerialIdMapping()}.
   *
   * <p>This method mutates the map in-place. {@code mutator} is a void consumer, so any value
   * returned from a lambda will be ignored. Take care not to call pure functions, like {@link
   * Collection#stream()}.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mutator} is null
   */
  public Employee.Builder mutateAssetsSerialIdMapping(Consumer<? super Map<String, Long>> mutator) {
    // If putAssetsSerialIdMapping is overridden, this method will be updated to delegate to it
    mutator.accept(assetsSerialIdMapping);
    return (Employee.Builder) this;
  }

  /**
   * Removes all of the mappings from the map to be returned from {@link
   * Employee#getAssetsSerialIdMapping()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearAssetsSerialIdMapping() {
    assetsSerialIdMapping.clear();
    return (Employee.Builder) this;
  }

  /**
   * Returns an unmodifiable view of the map that will be returned by {@link
   * Employee#getAssetsSerialIdMapping()}. Changes to this builder will be reflected in the view.
   */
  public Map<String, Long> getAssetsSerialIdMapping() {
    return Collections.unmodifiableMap(assetsSerialIdMapping);
  }

  /**
   * Sets the value to be returned by {@link Employee#getSalaryInUSD()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setSalaryInUSD(double salaryInUSD) {
    this.salaryInUSD = salaryInUSD;
    return (Employee.Builder) this;
  }

  /**
   * Sets the value to be returned by {@link Employee#getSalaryInUSD()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setSalaryInUSD(Optional<? extends Double> salaryInUSD) {
    if (salaryInUSD.isPresent()) {
      return setSalaryInUSD(salaryInUSD.get());
    } else {
      return clearSalaryInUSD();
    }
  }

  /**
   * Sets the value to be returned by {@link Employee#getSalaryInUSD()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder setNullableSalaryInUSD(@Nullable Double salaryInUSD) {
    if (salaryInUSD != null) {
      return setSalaryInUSD(salaryInUSD);
    } else {
      return clearSalaryInUSD();
    }
  }

  /**
   * If the value to be returned by {@link Employee#getSalaryInUSD()} is present, replaces it by
   * applying {@code mapper} to it and using the result.
   *
   * <p>If the result is null, clears the value.
   *
   * @return this {@code Builder} object
   * @throws NullPointerException if {@code mapper} is null
   */
  public Employee.Builder mapSalaryInUSD(UnaryOperator<Double> mapper) {
    return setSalaryInUSD(getSalaryInUSD().map(mapper));
  }

  /**
   * Sets the value to be returned by {@link Employee#getSalaryInUSD()} to {@link Optional#empty()
   * Optional.empty()}.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clearSalaryInUSD() {
    salaryInUSD = null;
    return (Employee.Builder) this;
  }

  /** Returns the value that will be returned by {@link Employee#getSalaryInUSD()}. */
  public Optional<Double> getSalaryInUSD() {
    return Optional.ofNullable(salaryInUSD);
  }

  /**
   * Copies values from {@code value}, appending to collections, and skipping defaults and empty
   * optionals.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder mergeFrom(Employee value) {
    Employee_Builder defaults = new Employee.Builder();
    if (defaults._unsetProperties.contains(Property.NAME)
        || !Objects.equals(value.getName(), defaults.getName())) {
      setName(value.getName());
    }
    if (defaults._unsetProperties.contains(Property.AGE) || value.getAge() != defaults.getAge()) {
      setAge(value.getAge());
    }
    if (defaults._unsetProperties.contains(Property.DEPARTMENT)
        || !Objects.equals(value.getDepartment(), defaults.getDepartment())) {
      setDepartment(value.getDepartment());
    }
    if (defaults._unsetProperties.contains(Property.ROLE)
        || !Objects.equals(value.getRole(), defaults.getRole())) {
      setRole(value.getRole());
    }
    if (defaults._unsetProperties.contains(Property.SUPERVISOR_NAME)
        || !Objects.equals(value.getSupervisorName(), defaults.getSupervisorName())) {
      setSupervisorName(value.getSupervisorName());
    }
    if (defaults._unsetProperties.contains(Property.DESIGNATION)
        || !Objects.equals(value.getDesignation(), defaults.getDesignation())) {
      setDesignation(value.getDesignation());
    }
    if (defaults._unsetProperties.contains(Property.EMAIL)
        || !Objects.equals(value.getEmail(), defaults.getEmail())) {
      setEmail(value.getEmail());
    }
    if (defaults._unsetProperties.contains(Property.PHONE_NUMBER)
        || value.getPhoneNumber() != defaults.getPhoneNumber()) {
      setPhoneNumber(value.getPhoneNumber());
    }
    value.getPermanent().ifPresent(this::setPermanent);
    value.getDateOfJoining().ifPresent(this::setDateOfJoining);
    if (!Objects.equals(value.getCurrentProject(), defaults.getCurrentProject())) {
      setCurrentProject(value.getCurrentProject());
    }
    if (address == null) {
      address = value.getAddress();
    } else {
      getAddressBuilder().mergeFrom(value.getAddress());
    }
    addAllAccessTokens(value.getAccessTokens());
    putAllAssetsSerialIdMapping(value.getAssetsSerialIdMapping());
    value.getSalaryInUSD().ifPresent(this::setSalaryInUSD);
    return (Employee.Builder) this;
  }

  /**
   * Copies values from {@code template}, appending to collections, and skipping defaults, empty
   * optionals and unset properties.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder mergeFrom(Employee.Builder template) {
    // Upcast to access private fields; otherwise, oddly, we get an access violation.
    Employee_Builder base = template;
    Employee_Builder defaults = new Employee.Builder();
    if (!base._unsetProperties.contains(Property.NAME)
        && (defaults._unsetProperties.contains(Property.NAME)
            || !Objects.equals(template.getName(), defaults.getName()))) {
      setName(template.getName());
    }
    if (!base._unsetProperties.contains(Property.AGE)
        && (defaults._unsetProperties.contains(Property.AGE)
            || template.getAge() != defaults.getAge())) {
      setAge(template.getAge());
    }
    if (!base._unsetProperties.contains(Property.DEPARTMENT)
        && (defaults._unsetProperties.contains(Property.DEPARTMENT)
            || !Objects.equals(template.getDepartment(), defaults.getDepartment()))) {
      setDepartment(template.getDepartment());
    }
    if (!base._unsetProperties.contains(Property.ROLE)
        && (defaults._unsetProperties.contains(Property.ROLE)
            || !Objects.equals(template.getRole(), defaults.getRole()))) {
      setRole(template.getRole());
    }
    if (!base._unsetProperties.contains(Property.SUPERVISOR_NAME)
        && (defaults._unsetProperties.contains(Property.SUPERVISOR_NAME)
            || !Objects.equals(template.getSupervisorName(), defaults.getSupervisorName()))) {
      setSupervisorName(template.getSupervisorName());
    }
    if (!base._unsetProperties.contains(Property.DESIGNATION)
        && (defaults._unsetProperties.contains(Property.DESIGNATION)
            || !Objects.equals(template.getDesignation(), defaults.getDesignation()))) {
      setDesignation(template.getDesignation());
    }
    if (!base._unsetProperties.contains(Property.EMAIL)
        && (defaults._unsetProperties.contains(Property.EMAIL)
            || !Objects.equals(template.getEmail(), defaults.getEmail()))) {
      setEmail(template.getEmail());
    }
    if (!base._unsetProperties.contains(Property.PHONE_NUMBER)
        && (defaults._unsetProperties.contains(Property.PHONE_NUMBER)
            || template.getPhoneNumber() != defaults.getPhoneNumber())) {
      setPhoneNumber(template.getPhoneNumber());
    }
    template.getPermanent().ifPresent(this::setPermanent);
    template.getDateOfJoining().ifPresent(this::setDateOfJoining);
    if (!Objects.equals(template.getCurrentProject(), defaults.getCurrentProject())) {
      setCurrentProject(template.getCurrentProject());
    }
    if (base.address == null) {
      // Nothing to merge
    } else if (base.address instanceof Address) {
      Address addressValue = (Address) base.address;
      if (address == null) {
        address = addressValue;
      } else {
        getAddressBuilder().mergeFrom(addressValue);
      }
    } else {
      getAddressBuilder().mergeFrom(base.getAddressBuilder());
    }
    addAllAccessTokens(base.accessTokens);
    putAllAssetsSerialIdMapping(base.assetsSerialIdMapping);
    template.getSalaryInUSD().ifPresent(this::setSalaryInUSD);
    return (Employee.Builder) this;
  }

  /**
   * Resets the state of this builder.
   *
   * @return this {@code Builder} object
   */
  public Employee.Builder clear() {
    Employee_Builder defaults = new Employee.Builder();
    name = defaults.name;
    age = defaults.age;
    department = defaults.department;
    role = defaults.role;
    supervisorName = defaults.supervisorName;
    designation = defaults.designation;
    email = defaults.email;
    phoneNumber = defaults.phoneNumber;
    permanent = defaults.permanent;
    dateOfJoining = defaults.dateOfJoining;
    currentProject = defaults.currentProject;
    if (address == null || address instanceof Address) {
      address = null;
    } else {
      Address.Builder addressBuilder = (Address.Builder) address;
      addressBuilder.clear();
    }
    clearAccessTokens();
    assetsSerialIdMapping.clear();
    salaryInUSD = defaults.salaryInUSD;
    _unsetProperties.clear();
    _unsetProperties.addAll(defaults._unsetProperties);
    return (Employee.Builder) this;
  }

  /**
   * Returns a newly-created {@link Employee} based on the contents of this {@code Builder}.
   *
   * @throws IllegalStateException if any field has not been set
   */
  public Employee build() {
    if (!_unsetProperties.isEmpty()) {
      throw new IllegalStateException("Not set: " + _unsetProperties);
    }
    return new Value(this);
  }

  /**
   * Returns a newly-created partial {@link Employee} for use in unit tests. State checking will not
   * be performed. Unset properties will throw an {@link UnsupportedOperationException} when
   * accessed via the partial object.
   *
   * <p>The builder returned by {@link Employee.Builder#from(Employee)} will propagate the partial
   * status of its input, overriding {@link Employee.Builder#build() build()} to return another
   * partial. This allows for robust tests of modify-rebuild code.
   *
   * <p>Partials should only ever be used in tests. They permit writing robust test cases that won't
   * fail if this type gains more application-level constraints (e.g. new required fields) in
   * future. If you require partially complete values in production code, consider using a Builder.
   */
  public Employee buildPartial() {
    return new Partial(this);
  }

  private abstract static class Rebuildable implements Employee {
    public abstract Builder toBuilder();
  }

  private static final class Value extends Rebuildable {
    private final String name;
    private final int age;
    private final String department;
    private final String role;
    private final String supervisorName;
    private final String designation;
    private final String email;
    private final long phoneNumber;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final Boolean permanent;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String dateOfJoining;
    @Nullable private final String currentProject;
    private final Address address;
    private final List<Long> accessTokens;
    private final Map<String, Long> assetsSerialIdMapping;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final Double salaryInUSD;

    private Value(Employee_Builder builder) {
      this.name = builder.name;
      this.age = builder.age;
      this.department = builder.department;
      this.role = builder.role;
      this.supervisorName = builder.supervisorName;
      this.designation = builder.designation;
      this.email = builder.email;
      this.phoneNumber = builder.phoneNumber;
      this.permanent = builder.permanent;
      this.dateOfJoining = builder.dateOfJoining;
      this.currentProject = builder.currentProject;
      if (builder.address == null) {
        this.address = new Address.Builder().build();
      } else if (builder.address instanceof Address) {
        this.address = (Address) builder.address;
      } else {
        Address.Builder addressBuilder = (Address.Builder) builder.address;
        this.address = addressBuilder.build();
      }
      this.accessTokens = immutableList(builder.accessTokens);
      this.assetsSerialIdMapping = immutableMap(builder.assetsSerialIdMapping);
      this.salaryInUSD = builder.salaryInUSD;
    }

    @Override
    public String getName() {
      return name;
    }

    @Override
    public int getAge() {
      return age;
    }

    @Override
    public String getDepartment() {
      return department;
    }

    @Override
    public String getRole() {
      return role;
    }

    @Override
    public String getSupervisorName() {
      return supervisorName;
    }

    @Override
    public String getDesignation() {
      return designation;
    }

    @Override
    public String getEmail() {
      return email;
    }

    @Override
    public long getPhoneNumber() {
      return phoneNumber;
    }

    @Override
    public Optional<Boolean> getPermanent() {
      return Optional.ofNullable(permanent);
    }

    @Override
    public Optional<String> getDateOfJoining() {
      return Optional.ofNullable(dateOfJoining);
    }

    @Override
    @Nullable
    public String getCurrentProject() {
      return currentProject;
    }

    @Override
    public Address getAddress() {
      return address;
    }

    @Override
    public List<Long> getAccessTokens() {
      return accessTokens;
    }

    @Override
    public Map<String, Long> getAssetsSerialIdMapping() {
      return assetsSerialIdMapping;
    }

    @Override
    public Optional<Double> getSalaryInUSD() {
      return Optional.ofNullable(salaryInUSD);
    }

    @Override
    public Builder toBuilder() {
      Employee_Builder builder = new Builder();
      builder.name = name;
      builder.age = age;
      builder.department = department;
      builder.role = role;
      builder.supervisorName = supervisorName;
      builder.designation = designation;
      builder.email = email;
      builder.phoneNumber = phoneNumber;
      builder.permanent = permanent;
      builder.dateOfJoining = dateOfJoining;
      builder.currentProject = currentProject;
      builder.address = new Address.Builder().mergeFrom(address);
      builder.accessTokens.addAll(accessTokens);
      builder.assetsSerialIdMapping.putAll(assetsSerialIdMapping);
      builder.salaryInUSD = salaryInUSD;
      builder._unsetProperties.clear();
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Value)) {
        return false;
      }
      Value other = (Value) obj;
      return Objects.equals(name, other.name)
          && age == other.age
          && Objects.equals(department, other.department)
          && Objects.equals(role, other.role)
          && Objects.equals(supervisorName, other.supervisorName)
          && Objects.equals(designation, other.designation)
          && Objects.equals(email, other.email)
          && phoneNumber == other.phoneNumber
          && Objects.equals(permanent, other.permanent)
          && Objects.equals(dateOfJoining, other.dateOfJoining)
          && Objects.equals(currentProject, other.currentProject)
          && Objects.equals(address, other.address)
          && Objects.equals(accessTokens, other.accessTokens)
          && Objects.equals(assetsSerialIdMapping, other.assetsSerialIdMapping)
          && Objects.equals(salaryInUSD, other.salaryInUSD);
    }

    @Override
    public int hashCode() {
      return Objects.hash(
          name,
          age,
          department,
          role,
          supervisorName,
          designation,
          email,
          phoneNumber,
          permanent,
          dateOfJoining,
          currentProject,
          address,
          accessTokens,
          assetsSerialIdMapping,
          salaryInUSD);
    }

    @Override
    public String toString() {
      StringBuilder result =
          new StringBuilder("Employee{name=")
              .append(name)
              .append(", age=")
              .append(age)
              .append(", department=")
              .append(department)
              .append(", role=")
              .append(role)
              .append(", supervisorName=")
              .append(supervisorName)
              .append(", designation=")
              .append(designation)
              .append(", email=")
              .append(email)
              .append(", phoneNumber=")
              .append(phoneNumber);
      if (permanent != null) {
        result.append(", permanent=").append(permanent);
      }
      if (dateOfJoining != null) {
        result.append(", dateOfJoining=").append(dateOfJoining);
      }
      if (currentProject != null) {
        result.append(", currentProject=").append(currentProject);
      }
      result
          .append(", address=")
          .append(address)
          .append(", accessTokens=")
          .append(accessTokens)
          .append(", assetsSerialIdMapping=")
          .append(assetsSerialIdMapping);
      if (salaryInUSD != null) {
        result.append(", salaryInUSD=").append(salaryInUSD);
      }
      return result.append("}").toString();
    }
  }

  private static final class Partial extends Rebuildable {
    private final String name;
    private final int age;
    private final String department;
    private final String role;
    private final String supervisorName;
    private final String designation;
    private final String email;
    private final long phoneNumber;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final Boolean permanent;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final String dateOfJoining;
    @Nullable private final String currentProject;
    private final Address address;
    private final List<Long> accessTokens;
    private final Map<String, Long> assetsSerialIdMapping;
    // Store a nullable object instead of an Optional. Escape analysis then
    // allows the JVM to optimize away the Optional objects created by our
    // getter method.
    private final Double salaryInUSD;
    private final EnumSet<Property> _unsetProperties;

    Partial(Employee_Builder builder) {
      this.name = builder.name;
      this.age = builder.age;
      this.department = builder.department;
      this.role = builder.role;
      this.supervisorName = builder.supervisorName;
      this.designation = builder.designation;
      this.email = builder.email;
      this.phoneNumber = builder.phoneNumber;
      this.permanent = builder.permanent;
      this.dateOfJoining = builder.dateOfJoining;
      this.currentProject = builder.currentProject;
      if (builder.address == null) {
        this.address = new Address.Builder().buildPartial();
      } else if (builder.address instanceof Address) {
        this.address = (Address) builder.address;
      } else {
        Address.Builder addressBuilder = (Address.Builder) builder.address;
        this.address = addressBuilder.buildPartial();
      }
      this.accessTokens = immutableList(builder.accessTokens);
      this.assetsSerialIdMapping = immutableMap(builder.assetsSerialIdMapping);
      this.salaryInUSD = builder.salaryInUSD;
      this._unsetProperties = builder._unsetProperties.clone();
    }

    @Override
    public String getName() {
      if (_unsetProperties.contains(Property.NAME)) {
        throw new UnsupportedOperationException("name not set");
      }
      return name;
    }

    @Override
    public int getAge() {
      if (_unsetProperties.contains(Property.AGE)) {
        throw new UnsupportedOperationException("age not set");
      }
      return age;
    }

    @Override
    public String getDepartment() {
      if (_unsetProperties.contains(Property.DEPARTMENT)) {
        throw new UnsupportedOperationException("department not set");
      }
      return department;
    }

    @Override
    public String getRole() {
      if (_unsetProperties.contains(Property.ROLE)) {
        throw new UnsupportedOperationException("role not set");
      }
      return role;
    }

    @Override
    public String getSupervisorName() {
      if (_unsetProperties.contains(Property.SUPERVISOR_NAME)) {
        throw new UnsupportedOperationException("supervisorName not set");
      }
      return supervisorName;
    }

    @Override
    public String getDesignation() {
      if (_unsetProperties.contains(Property.DESIGNATION)) {
        throw new UnsupportedOperationException("designation not set");
      }
      return designation;
    }

    @Override
    public String getEmail() {
      if (_unsetProperties.contains(Property.EMAIL)) {
        throw new UnsupportedOperationException("email not set");
      }
      return email;
    }

    @Override
    public long getPhoneNumber() {
      if (_unsetProperties.contains(Property.PHONE_NUMBER)) {
        throw new UnsupportedOperationException("phoneNumber not set");
      }
      return phoneNumber;
    }

    @Override
    public Optional<Boolean> getPermanent() {
      return Optional.ofNullable(permanent);
    }

    @Override
    public Optional<String> getDateOfJoining() {
      return Optional.ofNullable(dateOfJoining);
    }

    @Override
    @Nullable
    public String getCurrentProject() {
      return currentProject;
    }

    @Override
    public Address getAddress() {
      return address;
    }

    @Override
    public List<Long> getAccessTokens() {
      return accessTokens;
    }

    @Override
    public Map<String, Long> getAssetsSerialIdMapping() {
      return assetsSerialIdMapping;
    }

    @Override
    public Optional<Double> getSalaryInUSD() {
      return Optional.ofNullable(salaryInUSD);
    }

    private static class PartialBuilder extends Builder {
      @Override
      public Employee build() {
        return buildPartial();
      }
    }

    @Override
    public Builder toBuilder() {
      Employee_Builder builder = new PartialBuilder();
      builder.name = name;
      builder.age = age;
      builder.department = department;
      builder.role = role;
      builder.supervisorName = supervisorName;
      builder.designation = designation;
      builder.email = email;
      builder.phoneNumber = phoneNumber;
      builder.permanent = permanent;
      builder.dateOfJoining = dateOfJoining;
      builder.currentProject = currentProject;
      builder.address = new Address.Builder().mergeFrom(address);
      builder.accessTokens.addAll(accessTokens);
      builder.assetsSerialIdMapping.putAll(assetsSerialIdMapping);
      builder.salaryInUSD = salaryInUSD;
      builder._unsetProperties.clear();
      builder._unsetProperties.addAll(_unsetProperties);
      return (Builder) builder;
    }

    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof Partial)) {
        return false;
      }
      Partial other = (Partial) obj;
      return Objects.equals(name, other.name)
          && age == other.age
          && Objects.equals(department, other.department)
          && Objects.equals(role, other.role)
          && Objects.equals(supervisorName, other.supervisorName)
          && Objects.equals(designation, other.designation)
          && Objects.equals(email, other.email)
          && phoneNumber == other.phoneNumber
          && Objects.equals(permanent, other.permanent)
          && Objects.equals(dateOfJoining, other.dateOfJoining)
          && Objects.equals(currentProject, other.currentProject)
          && Objects.equals(address, other.address)
          && Objects.equals(accessTokens, other.accessTokens)
          && Objects.equals(assetsSerialIdMapping, other.assetsSerialIdMapping)
          && Objects.equals(salaryInUSD, other.salaryInUSD)
          && Objects.equals(_unsetProperties, other._unsetProperties);
    }

    @Override
    public int hashCode() {
      return Objects.hash(
          name,
          age,
          department,
          role,
          supervisorName,
          designation,
          email,
          phoneNumber,
          permanent,
          dateOfJoining,
          currentProject,
          address,
          accessTokens,
          assetsSerialIdMapping,
          salaryInUSD,
          _unsetProperties);
    }

    @Override
    public String toString() {
      StringBuilder result = new StringBuilder("partial Employee{");
      if (!_unsetProperties.contains(Property.NAME)) {
        result.append("name=").append(name).append(", ");
      }
      if (!_unsetProperties.contains(Property.AGE)) {
        result.append("age=").append(age).append(", ");
      }
      if (!_unsetProperties.contains(Property.DEPARTMENT)) {
        result.append("department=").append(department).append(", ");
      }
      if (!_unsetProperties.contains(Property.ROLE)) {
        result.append("role=").append(role).append(", ");
      }
      if (!_unsetProperties.contains(Property.SUPERVISOR_NAME)) {
        result.append("supervisorName=").append(supervisorName).append(", ");
      }
      if (!_unsetProperties.contains(Property.DESIGNATION)) {
        result.append("designation=").append(designation).append(", ");
      }
      if (!_unsetProperties.contains(Property.EMAIL)) {
        result.append("email=").append(email).append(", ");
      }
      if (!_unsetProperties.contains(Property.PHONE_NUMBER)) {
        result.append("phoneNumber=").append(phoneNumber).append(", ");
      }
      if (permanent != null) {
        result.append("permanent=").append(permanent).append(", ");
      }
      if (dateOfJoining != null) {
        result.append("dateOfJoining=").append(dateOfJoining).append(", ");
      }
      if (currentProject != null) {
        result.append("currentProject=").append(currentProject).append(", ");
      }
      result
          .append("address=")
          .append(address)
          .append(", accessTokens=")
          .append(accessTokens)
          .append(", assetsSerialIdMapping=")
          .append(assetsSerialIdMapping);
      if (salaryInUSD != null) {
        result.append(", salaryInUSD=").append(salaryInUSD);
      }
      return result.append("}").toString();
    }
  }

  @SuppressWarnings("unchecked")
  private static <E> List<E> immutableList(List<E> elements) {
    switch (elements.size()) {
      case 0:
        return Collections.emptyList();
      case 1:
        return Collections.singletonList(elements.get(0));
      default:
        return (List<E>) (List<?>) Collections.unmodifiableList(Arrays.asList(elements.toArray()));
    }
  }

  private static <K, V> Map<K, V> immutableMap(Map<K, V> entries) {
    switch (entries.size()) {
      case 0:
        return Collections.emptyMap();
      case 1:
        Map.Entry<K, V> entry = entries.entrySet().iterator().next();
        return Collections.singletonMap(entry.getKey(), entry.getValue());
      default:
        return Collections.unmodifiableMap(new LinkedHashMap<>(entries));
    }
  }
}
